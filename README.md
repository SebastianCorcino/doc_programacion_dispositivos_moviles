![Banner](https://i.imgur.com/mbFiUzk.png)

# Frameworks populares para desarrollo de aplicaciones móviles

Este repositorio contiene información sobre varios frameworks populares utilizados para el desarrollo de aplicaciones móviles. Cada sección presenta una descripción del framework, los lenguajes de programación utilizados, enlaces a la página oficial, repositorios de ejemplos, creadores y empresas responsables del mantenimiento, y una comparación con otras tecnologías.

![NodePing status](https://img.shields.io/nodeping/status/jkiwn052-ntpp-4lbb-8d45-ihew6d9ucoei?color=orange&label=Frameworks&up_message=Moviles)

- ## [Flutter](https://github.com/SebastianCorcino/doc_programacion_dispositivos_moviles/tree/Flutter)

Flutter tiene varias características interesantes y únicas que lo hacen destacar como framework de desarrollo de aplicaciones móviles. Aquí hay algunas características curiosas de Flutter:

1. Hot Reload
2. Widgets estilables
3. Compatibilidad con plataformas múltiples

---

Este es su twitter oficial ->
![Twitter URL](https://img.shields.io/twitter/url?style=social&url=https%3A%2F%2Ftwitter.com%2Fintent%2Ffollow%3Fscreen_name%3Dflutterdev)

- ## [Xamarin](https://github.com/SebastianCorcino/doc_programacion_dispositivos_moviles/tree/Ionic)

Xamarin, respaldado por Microsoft, es un framework de desarrollo de aplicaciones móviles con características distintivas. A continuación se presentan algunas de las características clave de Xamarin:

1. Lenguaje de programación C#
2. Gran comunidad y soporte
3. Integración con el ecosistema de Microsoft

- ## [React Native](https://github.com/SebastianCorcino/doc_programacion_dispositivos_moviles/tree/ReactNative)

React Native es un popular framework de desarrollo de aplicaciones móviles que tiene varias características destacadas. A continuación se presentan algunas de las características clave de React Native:

1. Basado en componentes
2. Escritura en JavaScript
3. Hot Reload

Ejemplo:

```jsx
const YourApp = () => {
  return (
    <View
      style={{
        flex: 1,
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      <Text>Try editing me! 🎉</Text>
    </View>
  );
};
export default YourApp;
```

- ## [Ionic](https://github.com/SebastianCorcino/doc_programacion_dispositivos_moviles/tree/Ionic)

![NodePing status](https://img.shields.io/nodeping/status/jkiwn052-ntpp-4lbb-8d45-ihew6d9ucoei)

Ionic es un framework de desarrollo de aplicaciones móviles híbridas que ofrece varias características distintivas. Aquí están algunas de las características clave de Ionic:

1. Integración con Angular
2. UI preestilizada y componentes reutilizables
3. Basado en tecnologías web

- ## [Swiftic](https://github.com/SebastianCorcino/doc_programacion_dispositivos_moviles/tree/Swiftic)

Swiftic es un framework para el desarrollo de aplicaciones móviles nativas en iOS. Aqui algunas de sus caracteristicas.

1. Construcción de aplicaciones nativas
2. Soporte y análisis
3. Amplia gama de plantillas

# Patrones de diseño

- ## Factory Method

Factory Method es un patrón de diseño creacional que proporciona una interfaz para crear objetos en una superclase, mientras permite a las subclases alterar el tipo de objetos que se crearán.

- ## Abstract Factory

Abstract Factory es un patrón de diseño creacional que nos permite producir familias de objetos relacionados sin especificar sus clases concretas.

- ## Adapter

Adapter es un patrón de diseño estructural que permite la colaboración entre objetos con interfaces incompatibles.

- ## Bridge

Bridge es un patrón de diseño estructural que te permite dividir una clase grande, o un grupo de clases estrechamente relacionadas, en dos jerarquías separadas (abstracción e implementación) que pueden desarrollarse independientemente la una de la otra.

- ## Builder

Builder es un patrón de diseño creacional que nos permite construir objetos complejos paso a paso. El patrón nos permite producir distintos tipos y representaciones de un objeto empleando el mismo código de construcción.

- ## Prototype

Prototype es un patrón de diseño creacional que nos permite copiar objetos existentes sin que el código dependa de sus clases.

- ## Composite

Composite es un patrón de diseño estructural que te permite componer objetos en estructuras de árbol y trabajar con esas estructuras como si fueran objetos individuales.

- ## Decorator

Decorator es un patrón de diseño estructural que te permite añadir funcionalidades a objetos colocando estos objetos dentro de objetos encapsuladores especiales que contienen estas funcionalidades.

- ## Singleton

Singleton es un patrón de diseño creacional que nos permite asegurarnos de que una clase tenga una única instancia, a la vez que proporciona un punto de acceso global a dicha instancia.

- ## Facade

Facade es un patrón de diseño estructural que proporciona una interfaz simplificada a una biblioteca, un framework o cualquier otro grupo complejo de clases.

- ## Flyweight

Flyweight es un patrón de diseño estructural que te permite mantener más objetos dentro de la cantidad disponible de RAM compartiendo las partes comunes del estado entre varios objetos en lugar de mantener toda la información en cada objeto.

- ## Proxy

Proxy es un patrón de diseño estructural que te permite proporcionar un sustituto o marcador de posición para otro objeto. Un proxy controla el acceso al objeto original, permitiéndote hacer algo antes o después de que la solicitud llegue al objeto original.

- ## Chain of Responsibility

Chain of Responsibility es un patrón de diseño de comportamiento que te permite pasar solicitudes a lo largo de una cadena de manejadores. Al recibir una solicitud, cada manejador decide si la procesa o si la pasa al siguiente manejador de la cadena.

- ## Command

Command es un patrón de diseño de comportamiento que convierte una solicitud en un objeto independiente que contiene toda la información sobre la solicitud. Esta transformación te permite parametrizar los métodos con diferentes solicitudes, retrasar o poner en cola la ejecución de una solicitud y soportar operaciones que no se pueden realizar.

- ## Iterator

Iterator es un patrón de diseño de comportamiento que te permite recorrer elementos de una colección sin exponer su representación subyacente (lista, pila, árbol, etc.).

- ## Mediator

Mediator es un patrón de diseño de comportamiento que te permite reducir las dependencias caóticas entre objetos. El patrón restringe las comunicaciones directas entre los objetos, forzándolos a colaborar únicamente a través de un objeto mediador.

- ## Memento

Memento es un patrón de diseño de comportamiento que te permite guardar y restaurar el estado previo de un objeto sin revelar los detalles de su implementación.

- ## Observer

Observer es un patrón de diseño de comportamiento que te permite definir un mecanismo de suscripción para notificar a varios objetos sobre cualquier evento que le suceda al objeto que están observando.

- ## State

State es un patrón de diseño de comportamiento que permite a un objeto alterar su comportamiento cuando su estado interno cambia. Parece como si el objeto cambiara su clase.

- ## Strategy

Strategy es un patrón de diseño de comportamiento que te permite definir una familia de algoritmos, colocar cada uno de ellos en una clase separada y hacer sus objetos intercambiables.

- ## Template Method

Template Method es un patrón de diseño de comportamiento que define el esqueleto de un algoritmo en la superclase pero permite que las subclases sobrescriban pasos del algoritmo sin cambiar su estructura.

- ## Visitor

Visitor es un patrón de diseño de comportamiento que te permite separar algoritmos de los objetos sobre los que operan.

# Redux

Redux es una biblioteca de administración de estado para aplicaciones JavaScript, especialmente aquellas que tienen interfaces de usuario complejas. Proporciona un enfoque predecible y centralizado para manejar el estado de una aplicación, lo que facilita el seguimiento y la actualización del estado a medida que la aplicación crece y se vuelve más compleja.

# Context

El Context es una característica que permite pasar datos a través del árbol de componentes sin necesidad de pasar props manualmente en cada nivel. Proporciona una forma de compartir datos entre componentes que están anidados en la jerarquía de componentes sin tener que pasar los datos explícitamente a través de las propiedades.
